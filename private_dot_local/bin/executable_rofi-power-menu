#!/usr/bin/env bash

# This script defines just a mode for rofi instead of being a self-contained
# executable that launches rofi by itself. This makes it more flexible than
# running rofi inside this script as now the user can call rofi as one pleases.

set -e
set -u

# All supported choices
all=(shutdown reboot suspend hibernate logout lockscreen)

# By default, show all (i.e., just copy the array)
show=("${all[@]}")

declare -A texts
texts[lockscreen]="lock"
texts[logout]="logout"
texts[suspend]="suspend"
texts[hibernate]="hibernate"
texts[reboot]="reboot"
texts[shutdown]="shutdown"

declare -A icons
icons[lockscreen]="󰌾"
icons[logout]="󰍃"
icons[suspend]="󰒲"
icons[hibernate]="󰤄"
icons[reboot]="󰜉"
icons[shutdown]="󰐥"
icons[cancel]="󰜺"

declare -A actions
actions[lockscreen]="swaylock"
actions[logout]="swaymsg exit"
actions[suspend]="systemctl suspend"
actions[hibernate]="systemctl hibernate"
actions[reboot]="systemctl reboot"
actions[shutdown]="systemctl poweroff"

# By default, ask for confirmation for actions that are irreversible
confirmations=(reboot shutdown logout)

# By default, no dry run
dryrun=false
showsymbols=true
showtext=true

function check_valid {
  option="$1"
  shift 1
  for entry in "${@}"; do
    if [ -z "${actions[$entry]+x}" ]; then
      echo "Invalid choice in $1: $entry" >&2
      exit 1
    fi
  done
}

# Parse command-line options
parsed=$(getopt --options=h --longoptions=help,dry-run,confirm:,choices:,choose:,symbols,no-symbols,text,no-text --name "$0" -- "$@")
if [ $? -ne 0 ]; then
  echo 'Terminating...' >&2
  exit 1
fi
eval set -- "$parsed"
unset parsed
while true; do
  case "$1" in
  "-h" | "--help")
    echo "rofi-power-menu - a power menu mode for Rofi"
    echo
    echo "Usage: rofi-power-menu [--choices CHOICES] [--confirm CHOICES]"
    echo "                       [--choose CHOICE] [--dry-run] [--symbols|--no-symbols]"
    exit 0
    ;;
  "--dry-run")
    dryrun=true
    shift 1
    ;;
  "--confirm")
    IFS='/' read -ra confirmations <<<"$2"
    check_valid "$1" "${confirmations[@]}"
    shift 2
    ;;
  "--choices")
    IFS='/' read -ra show <<<"$2"
    check_valid "$1" "${show[@]}"
    shift 2
    ;;
  "--choose")
    check_valid "$1" "$2"
    selectionID="$2"
    shift 2
    ;;
  "--symbols")
    showsymbols=true
    shift 1
    ;;
  "--no-symbols")
    showsymbols=false
    shift 1
    ;;
  "--text")
    showtext=true
    shift 1
    ;;
  "--no-text")
    showtext=false
    shift 1
    ;;
  "--")
    shift
    break
    ;;
  *)
    echo "Internal error" >&2
    exit 1
    ;;
  esac
done

if [ "$showsymbols" = "false" -a "$showtext" = "false" ]; then
  echo "Invalid options: cannot have --no-symbols and --no-text enabled at the same time." >&2
  exit 1
fi

function write_message {
  icon="$1"
  text="$2"
  if [ "$showsymbols" = "true" ]; then
    if [ "$showtext" = "true" ]; then
      echo -n "$icon $text"
    else
      echo -n "$icon"
    fi
  else
    echo -n "$text"
  fi
}

function print_selection {
  echo -e "$1" | $(
    read -r -d '' entry
    echo "echo $entry"
  )
}

declare -A messages
declare -A confirmationMessages
for entry in "${all[@]}"; do
  messages[$entry]=$(write_message "${icons[$entry]}" "${texts[$entry]}")
done
for entry in "${all[@]}"; do
  confirmationMessages[$entry]=$(write_message "${icons[$entry]}" "yes, ${texts[$entry]}")
done
confirmationMessages[cancel]=$(write_message "${icons[cancel]}" "no, cancel")

if [ $# -gt 0 ]; then
  selection="${@}"
else
  if [ -n "${selectionID+x}" ]; then
    selection="${messages[$selectionID]}"
  fi
fi

# Don't allow custom entries
echo -e "\0no-custom\x1ftrue"

if [ -z "${selection+x}" ]; then
  echo -e "\0prompt\x1fPower menu"
  for entry in "${show[@]}"; do
    echo "${messages[$entry]}"
  done
else
  for entry in "${show[@]}"; do
    if [ "$selection" = "$(print_selection "${messages[$entry]}")" ]; then
      for confirmation in "${confirmations[@]}"; do
        if [ "$entry" = "$confirmation" ]; then
          echo -e "\0prompt\x1fconfirm"
          echo "${confirmationMessages[$entry]}"
          echo "${confirmationMessages[cancel]}"
          exit 0
        fi
      done
      selection=$(print_selection "${confirmationMessages[$entry]}")
    fi
    if [ "$selection" = "$(print_selection "${confirmationMessages[$entry]}")" ]; then
      if [ $dryrun = true ]; then
        echo "Selected: $entry" >&2
      else
        ${actions[$entry]}
      fi
      exit 0
    fi
    if [ "$selection" = "$(print_selection "${confirmationMessages[cancel]}")" ]; then
      exit 0
    fi
  done
  echo "Invalid selection: $selection" >&2
  exit 1
fi
